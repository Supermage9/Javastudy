/*
무결성 제약조건
  - 데이터를 추가, 수정, 삭제하는 과정에서 무결성을 유지할 수 있도록 제약을 주는 것을 의미함
  - 무결성: 데이터베이스 내에 데이터의 확장성을 유지하는 것을 의미하고, 제약 조건이란
    제약조건: 바람직하지 않은 데이터가 저장되는 것을 방지하기 위함
    
    무결성 제약 조건
    NOT NULL    : NULL을 허용하지 않는다.
    UNIQUE      : 중복된 값을 허용하지 않는다. 항상 유일한 값을 갖도록 함
    PRIMARY KEY : NOT NULL + UNIQUE 조건을 결합한 형태를 의미함
    FOREIGN KEY : 참조되는 테이블의 컬럼값이 존재하면 허용됨
    CHECK       : 저장 가능한 데이터 값의 범위나 조건을 지정하여 설정한 값만을 허용함
*/

select * from emp01;
create table emp01(
empno number(4),
ename varchar(10),
job varchar2(9),
depno number(4));

insert into emp01 values(null,null,'salesman',30);
select * from emp01;
-- NOT NULL 제약조건은 해당 컬럼에 null값을 추가하거나 null값으로 변경하는 것을 막음
-- 제약조건은 컬럼명과 자료형을 기술한 후에 이어서 not null을 기술하면 됨

create table emp02(
empno number(4) not null,
ename varchar(10) not null,
job varchar2(9),
depno number(4));
insert into emp02 values(null,null,'salesman',30);

-- UNIQUE: 중복된 값을 허용하지 않는다. 항상 유일한 값을 갖도록 함

create table emp03(
empno number(4) UNIQUE,
ename varchar(10) not null,
job varchar2(9),
depno number(4));
insert into emp03 values(7499,'ALLEN','salesman',30);
insert into emp03 values(NULL,'HAEYOUNG','manager',20);
insert into emp03 values(null,'ALLEN','salesman',10);

/*
 unique: null값을 예외로 간주함, 만약 null값 마저도 입력되지 않게 제한 하려면
         테이블 생성시 empno number(4) unique not null처럼 두 가지 제약조건을
         기술해야함
*/
desc user_tables;

show user;

/*
제약 조건 확인 하기
  제약조건의 에러 메시지에 대한 정확한 원인을 알기 위해 오라클에서 제공해 주는 user_constraints 데이터 딕셔너리
  
    user_constraint 데이터 딕셔너리
      - 제약조건의 정보를 위해서 많은 컬럼으로 구성되어 있지만
        제약조건명, 제약 조건유형, 제약 조건이 속한 테이블만을 알아봄
*/

select constraint_name, constraint_type, table_name from user_constraints where table_name='EMP03';


/*
제약 조건 확인하기
  제약조건의 에러 메세지에 대한 정확한 원인을 알기 위해 오라클에서 제공해 주는 user_constraints
  데이터 딕셔너리
  
  user constraints 데이터 딕셔너리
    - 제약조건의 정보를 위해서 많은 컬럼으로 구성되어 있지만
      제약조건명, 제약 조건유형, 제약 조건이 속한 테이블만을 알아봄
*/
select constraint_name, constraint_type, table_name from user_constraints where table_name = 'EMP03';

/*
 constraint_type 은 p,r,u,c 4가지가 있음
 
       P : PRIMARY KEY
       R : FOREIGN KEY
       U : UNIQUE
       C : CHECK NOT NULL
*/
/*
  PRIMARY KEY 제약 조건
    - 식별 기능을 갖는 컬럼은 유일하면서도 NULL 값을 허용하지 않음
      즉, UNIQUE와 not null 제약 조건 모두를 갖는 것이 기본키(PRIMARY KEY) 제약조건임.
*/
create table emp04(
empno number(4) PRIMARY KEY,
ename varchar(10) not null,
job varchar2(9),
depno number(4));

insert into emp04 values(7499,'ALLEN','SALESMAN',30);
insert into emp04 values(7499,'JONES','MANAGER',20);


select constraint_name, constraint_type, table_name from user_constraints where table_name = 'EMP04';

select * from emp04;
insert into emp04 values(7566,'JONES','MANAGER',50);
delete from emp04 where depno=20;


create table emp05(
empno number(4) PRIMARY KEY,
ename varchar(10) not null,
job varchar2(9),
deptno number(4));

select * from dept01;

create table dept01(
deptno number(2) PRIMARY key,
dname varchar2(14),
loc VARCHAR2(13)
);

insert into dept01 values(10,'ACCOUNTING','NEW YORK');
insert into dept01 values(20,'RESEARCH','DALLAS');
insert into dept01 values(30,'SALES','CHICAGO');
insert into dept01 values(40,'OPERATIONS','BOSTON');

create table emp05(
empno number(4) PRIMARY KEY,
ename varchar(10) not null,
job varchar2(9),
deptno number(4)REFERENCES dept01(deptno)
);

select constraint_name, constraint_type, table_name from user_constraints where table_name = 'EMP05';
select * from emp05;
insert into emp05 values(7499,'ALLEN','SALESMAN',30);
insert into emp05 values(7566,'JONES','MANAGER',50);

drop table dept01; 
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'EMP05';

select * from tab;
--------------------------------------------------------------------------------

/*
   CHECK 제약조건
     - 입력되는 값을 체크하여 설정된 값 이외의 값이 들어오면 오류 메세지와 함께 명령이 수행되지 못하게 하는 것
*/
/*
   EMP06 사원테이블에 GENDER(성별) 컬럼을 추가하되 GENDER 컬럼에는 'M'or'F' 두 값만 저장할 수 있는 CHECK 제약 조건 설정
*/

create table emp06(
empno number(4) PRIMARY key,
ename VARCHAR2(10) not null,
gender VARCHAR2(1) check(gender in('M','F'))
); 
insert into emp06 values (7566,'JONES','M');
select constraint_name, constraint_type, table_name, search_condition from user_constraints where table_name = 'EMP06';

/*
제약조건명 지정하기
 - 사용자가 의미있게 제약조건명을 명시하여 제약조건명만으로 어떤 제약조건을 위배했는지 알 수 있게 하는 방법
     지정방법 : COLUMN_NAME DATA_TYPE CONTRAINT constraint_name constraint_type
     
   제약조건명 명명규칙
     테이블명_컬럼명_제약조건 유형
     
   기본키 제약 조건명을 EMP06_EMPNO_PK로 지정함
     EMP05_EMPNO_PK
*/

drop table emp05;

create table emp05(
empno number(4)CONSTRAINT EMP05_EMPNO_PK PRIMARY KEY,
ename VARCHAR2(10)CONSTRAINT EMP05_ENAME_NN Not null,
job VARCHAR2(9)CONSTRAINT EMP05_JOB_UK UNIQUE,
deptno NUMBER(4)CONSTRAINT EMP05_DEPTNO_FK REFERENCES DEPT01(DEPTNO)
);

select constraint_name, constraint_type, table_name, search_condition from user_constraints where table_name = 'EMP05';

insert into emp05 values (7499,'ALLEN','SALESMAN',30);
insert into emp05 values (7499,'NULL','SALESMAN',50);
insert into emp05 values (7499,'ALLEN','SALESMAN',50);
insert into emp05 values (7500,'ALLEN','SALESMAN',50);

/*
   테이블 레벨 방식으로 제약조건 지정하기

     복합키로 기본키를 지정할 경우
      - 복합키 형태로 제약조건을 지정할 경우에는 컬럼 레벨 형식으로는 
        불가능하고 반드시!! 테이블 레벨 방식을 사용함
      
     ALTER TABLE로 제약조건을 추가할 경우
      - 테이블의 정의가 완료되어 테이블의 구조가 결정된 후에 나중에 테이블에
        제약조건을 추가하고자 할때에는 테이블 레벨 방식으로 제약조건 지정
        
     형식
       create table 테이블명(
       컬럼명1 데이터 타입1,
       컬럼명2 데이터 타입1,
       ...
       
       CONSTRAINT constraint_name constraint_type(column_name)
       );
*/

-- 테이블 레벨로 제약조건을 지정하는 방식
select * from tab;
drop table emp04;

CREATE table emp04(
empno number(4),
ename VARCHAR2(10) not null,
job VARCHAR2(9),
deptno number(4),
PRIMARY key(empno),
unique(job),
FOREIGN key(deptno) REFERENCES dept01(deptno)
); -- 테이블 정의하고 밑에다 따로 키 지정해도 됨

drop table emp03;
--  테이블 레벨에서 컬럼의 제약조건명을 지정해줄 경우 constraint 키워드를 사용함
create table emp03(
empno number(4),
ename VARCHAR2(10) CONSTRAINT emp03_ename_nn not null,
job VARCHAR2(9),
deptno number(4),
CONSTRAINT emp03_empno_pk PRIMARY key(empno),
CONSTRAINT emp03_job_uk unique(job),
CONSTRAINT emp03_deptno_fk FOREIGN key(deptno) REFERENCES dept01(deptno)
);
select constraint_name, constraint_type, table_name, search_condition from user_constraints where table_name = 'EMP03';


--------------------------- end 제약조건 지정방식 ---------------------------------
--------------------------- 제약조건 변경 ----------------------------------------
/*
 1. 제약조건 추가하기
   - 테이블 생성이 끝난 후에 제약조건을 추가하기 위해 alter table로 추가함
   
    형식
      alter table 테이블명
      add constraint constraint_name constraint_type(column_name);
*/
drop table emp01;
create table emp01(
empno number(4),
ename VARCHAR2(10),
job VARCHAR2(9),
deptno number(4)
);
select constraint_name, constraint_type, table_name, search_condition, r_constraint_name from user_constraints where table_name = 'EMP01';

-- emp01 테이블의 empno 컬럼에 기본키 설정하고, deptno 컬럼에 외래키 설정
alter table emp01
add primary key(empno);

alter table emp01
add constraint emp01_deptno_fk FOREIGN key(deptno) REFERENCES dept01(deptno);


/* 
 2. 제약조건 제거하기
   - 제약조건을 제거하기 위해서는 drop constraint 다음에 제거하고자 하는 제약조건명을 명시
   alter table 테이블명
   drop constraint 제약조건명;
*/
select constraint_name, constraint_type, table_name, search_condition, r_constraint_name from user_constraints where table_name = 'EMP01';
insert into emp05 values (7499,'ALLEN','MASTER',50);

alter table emp05
drop constraint EMP05_EMPNO_PK;

alter table emp05
drop constraint EMP05_DEPTNO_FK;

/*
   제약조건의 비활성화 CASCADE;
     - 제약조건의 비활성화란 설정된 제약조건을 잠시 사용하지 않게 하는것
     
     disable : 제약조건의 일시 비활성화
     enable : 비활성화된 제약조건을 해제하여 다시 활성화
     
*/
select constraint_name, constraint_type, table_name, search_condition, r_constraint_name from user_constraints where table_name = 'DEPT01';
select * from dept01;
insert into dept01 values(10,'ACCOUNTING','NEW YORK');
delete from dept01 where deptno=30;



drop table emp01;
create table emp01(
empno number(4) constraint emp01_empno_pk PRIMARY key,
ename VARCHAR2(10) constraint emp01_ename_nn not null,
job VARCHAR2(9),
deptno number(4) constraint emp01_deptno_fk REFERENCES dept01(deptno)
);

insert into emp01 values(7499,'ALLEN','SALESMAN',10);
insert into emp01 values(7369,'SMITH','CLERK',20);

delete from dept01 where deptno=10;

/*
   제약조건 활성화와 비활성화
    
    - 제약조건이 설정되면 항상 그 규칙에 따라 데이터 무결성이 보장됨
      오라클에서는 제약조건을 비활성화시킴으로써 제약조건을 삭제하지 않고도 사용을 잠시
      보류할 수 있으며 비활성화된 제약조건은 원하는 작업을 한 후 다시 활성화 상태로
      만들어 주어야함.
  
   활성화 방법
     alter table 테이블명
     enable constraint 제약조건명;
  
   비활성화 방법
     alter table 테이블명
     disable constraint 제약조건명;
*/
alter table emp01
     disable constraint EMP01_DEPTNO_FK;

select constraint_name, constraint_type, table_name, search_condition, r_constraint_name,status from user_constraints where table_name = 'EMP01';

delete from dept01 where deptno=10;
rollback;

-- 활성화
alter table emp01
enable constraint emp01_deptno_fk;

/*
  CASCADE
    - cascade 옵션은 부모테이블(dept01)과 자식테이블(emp01)간의 참조 설정이 되어 있을때
      부모 테이블의 제약 조건을 비활성화하면 이를 참조하는 자식테이블의 제약조건까지
      같이 비활성화 시켜주는 옵션이다
*/
alter table dept01
disable primary key cascade;

select constraint_name, constraint_type, table_name, search_condition, r_constraint_name,status
from user_constraints where table_name in('DEPT01','EMP01');

/*
  CASCADE 옵션을 지정하여 기본키 제약조건을 삭제하면 이를 참조하는 외래키 제약조건도 연속적으로 삭제
*/
alter table dept01
drop primary key cascade;

select * from dept;
select * from emp;

select * from emp , dept where emp.deptno = dept.deptno;
select * from emp e, dept d where e.deptno = d.deptno; --이것도 가능


--------------------------------  조인 (Join)  ----------------------------------
/*
  조인 : 한개 이상의 테이블에서 데이터를 조회하기 위해 사용되는것
  
  종류
    Equi join : 동일한 컬럼을 기준으로 조인
    Nonqui join : 동일한 컬럼이 없이 다른 조건을 사용하여 조인
    Outer join : 조인 조건에 만족하지 않는 행도 나타냄
    Self join : 한 테이블 내에서 조인
*/


-- Equi join : 동일한 컬럼을 기준으로 조인
-- 두 테이블에서 공통적으로 존재하는 컬럼의 값이 일치되는 행을 연결하여 결과를 생성하는 조인
select ename,dname from emp,dept where emp.deptno=dept.deptno;


-- Nonqui join : 동일한 컬럼이 없이 다른 조건을 사용하여 조인
-- 조인할 테이블 사이에 컬럼의 값이 직접적으로 일치하지 않을시 사용하는 조인
select e.ename, e.sal, s.grade from emp e,salgrade s where e.sal between s.losal and s.hisal;
select e.ename, e.sal, s.grade from emp e,salgrade s where e.sal >= s.losal and e.sal <= s.hisal;


-- outer join : 조인 조건에 만족하지 않는 행도 나타냄.
--              행이 조인 조건에 만족하지 않을 경우 그 행은 결과에 나타나지 않게됨.
--              이때 조인 조건에 만족하지 않는 행들도 나타내기 위해 outer join을 사용함
select e.ename, d.deptno, d.dname from emp e, dept d where e.deptno(+) = d.deptno order by d.deptno; 
/*
    부서 테이블에는 40번 부서가 존재한다.
    하지만, 조인결과를 보게되면 10~30번 부서번호만 출력되고 40번은 출력되지 않는다.
    이는 사원테이블의 부서번호에는 40번이 존재하지 않기 때문이다.
    
    부서테이블의 40번 부서와 조인할 사원테이블의 부서번호가 없지만, 40번 부서도 출력되도록 하려면
    Outer join 을 사용하면 해결됨
     outer join을 사용하려면 기호를 사용하여 조인 조건에서 정보가 부족한 컬럼명 뒤에 위치하게 하면 됨.
*/
-- self join : 한 테이블 내에서 조인
select ename, mgr from emp;

-- emp 테이블에 별칭을 사용하여 하나의 테이블을 두개의 테이블인것처럼 사용하려면 
-- WORK(사원테이블),MANAGER(매니저 테이블)로 별칭을 부여한다.
select WORK.ename, MANAGER.ename from emp WORK, emp MANAGER where WORK.mgr = MANAGER.empno;


/*
  사원의 이름과 그의 매니저 이름을 출력하는 쿼리문 작성
*/
select WORK.ename || '의 매니저는' || MANAGER.ename ||'이다' 
from emp WORK, emp MANAGER where WORK.mgr = MANAGER.empno;


/*
  서브 쿼리
   
    서브쿼리는 하나의 select 문장의 절 안에 포함되는 또 하나의 select 문장이다.
    그렇기에 서브쿼리를 포함하고 있는 쿼리문을 메인쿼리, 포함된 또하나의 쿼리를 서브쿼리라고 함.
    서브쿼리의 종류는 단일행 서브쿼리, 다중행 서브쿼리가 있음
    서브쿼리문을 이용해서 테이블에 데이터를 추가, 수정, 삭제할 수 있음
    서브쿼리를 이용해 테이블 생성도 가능함
*/

-- 문] 이름이 SCOTT인 사원이 어떤부서 소속인지 소속 부서명을 알아내려면 조인을 사용해서
--     해결했지만, 조인이 아닌 서브쿼리를 이용해서도 해결이 가능하다.
-- 먼저 SCOTT의 부서명을 알아서 부서번호를 알아내야함.
select deptno from emp where ename = 'SCOTT';
select dname from dept where deptno = 20;

select dname from dept where deptno =(select deptno from emp where ename = 'SCOTT');
-- 서브쿼리는 비교연산자의 오른쪽에 기술해야 하고, 반드시 괄호()로 둘러싸야한다.
-- 서브쿼리는 메인쿼리가 실행되기 전에 한번만 실행함.

/*
  단일행 서브쿼리
  
    단일행 서브쿼리는 내부 select 문장으로부터 오직 하나의 행만을 반환받으며,
    단일행 비교연산자(=,>,>=,<,<=,<>)를 사용함
    
  다중행 서브쿼리
    
    서브쿼리에서 반환되는 결과가 하나이상의 행일때 사용하는 서브쿼리이다.
    
    다중행 연산자
    IN       : 메인쿼리의 비교 조건('='연산자로 비교할 경우)이 서브 쿼리의 결과 중에서 하나라도 일치하면 참
    ANY,SOME : 메인쿼리의 비교 조건이 서브쿼리의 검색 결과와 하나 이상 일치하면 참
    ALL      : 메인쿼리의 비교 조건이 서브쿼리의 검색 결과와 모든 값이 일치하면 참
    EXIST    : 메인쿼리의 비교 조건이 서브쿼리의 결과 중에서 만족하는 값이 하나라도 존재하면 참
*/
/*
  단일행 서브쿼리
  SMITH와 같은 부서에서 근무하는 사원의 정보를 출력하시오.(서브쿼리로 작성 : 단일행)
*/
select deptno from emp where ename = 'SMITH';
select * from emp where deptno = 20;
select * from emp where deptno = (select deptno from emp where ename = 'SMITH');

-- 사원테이블에서 평균 급여보다 더 많은 급여를 받는 사원을 검색하여 출력하시오.

-- 급여에 평균을 구한다.
select ename, sal from emp where sal > (select avg(sal) from emp);


-- IN 연산자
--   결과가 2개 이상 구해지는 쿼리문을 서브쿼리로 기술할 경우에는 다중행 연산자와 함께 사용해야함.

-- 급여를 3000 이상 받는 사원이 소속된 부서와 동일한 부서에서 근무하는 사원을 출력하시오
select distinct deptno from emp where sal>=3000;
select ename, sal, deptno from emp where deptno IN(select distinct deptno from emp where sal>=3000);
select ename, sal, deptno from emp where deptno = 10;
select ename, sal, deptno from emp where deptno = 20;


/*
   ANY
     - 메인 쿼리의 비교조건이 서브쿼리의 검색 결과와 하나이상 일치하면 참.
       찾아진 값에서 가장 작은 값 즉, 최소값보다 크면 참
       
       연산자 ANY는 찾아진 값에 대해 하나라도 크면 참.
*/

-- 부서번호가 30번인 사원들의 급여중 가장 작은 값(950) 보다 많은 급여를 받는
-- 사원의 이름, 급여를 출력하시오.
select ename,sal from emp where sal >=950 and deptno=30;
select sal from emp where deptno = 30;

select ename,sal from emp where sal >= ANY(select sal from emp where deptno = 30);


-- ALL : 메인 쿼리의 비교조건이 서브 쿼리의 검색결과와 모든 값이 일치하면 참
-- ex) 30번 소속사원들 중에서 급여를 가장 많 이받은 사원보다 더 많은 급여를 받는 사원을 이름, 급여를 출력하시오
-- 30번 부서 사원 급여들 모두에 대해 커야함 최대값보다 큰 급여를 받는 사람
select ename, sal from emp where sal>2850;
select sal from emp where deptno=30;

select ename, sal from emp where sal>all(select sal from emp where deptno=30);

-- 서브쿼리를 이용해서 테이블 작성
select * from tab;
create table emp07
as select * from emp where 1=0;
select * from emp07;

create table emp08
as select empno,ename from emp where 1=0;

create table dept02
as select * from dept where 1=0;
select * from dept02;


-- 서브쿼리를 이용한 데이터 추가
insert into dept02 select * from dept;

-- 서브쿼리를 이용한 데이터 수정
-- 10번 부서의 지역명을 40번 부서의 지역명으로 변경하시오. (컬럼이 하나인 경우)
update dept02 set loc = (select loc from dept02 where deptno=40) where deptno=10;

/* 컬럼이 2개 이상인 경우
   서브쿼리 형식 두가지
   1. update 테이블명
      set 컬럼명1 = (서브쿼리), 컬럼명2 = (서브쿼리) where 조건
   
   2. update 테이블명
      set (컬럼명1 , 컬럼명2) = (서브쿼리1,서브쿼리2) where 조건
*/

-- ex) 20번 부서의 부서명과 지역명을 30번 부서의 부서명과 지역명으로 변경하시오.
-- 첫번째 방법
update dept02 set dname = (select dname from dept02 where deptno=30),
loc = (select loc from dept02 where deptno=30) where deptno=20;

-- 두번째 방법
update dept02 set (dname,loc) = (select dname , loc from dept02 where deptno=30)
where deptno=20;


-- 서브쿼리를 이용한 데이터 삭제
select deptno from dept where dname='SALES';
delete from emp01 where deptno = 30;
rollback;

-- 문] 직급이 'SALESMAN'인 사원이 받는 급여들의 최소 급여보다 많이받는 사원들의 이름과 급여를 출력하되,
--     부서번호가 20번인 사원은 제외시키고 출력하시오.
select min(sal) from emp where job = 'SALESMAN';
select ename, sal, deptno from emp where deptno !=20 and sal > (select min(sal) from emp where job = 'SALESMAN');


-- 사용자 생성
-- create user 유저명 identified by 비밀번호
-- 유저명 : javauser, 비밀번호 : java
create user javauser identified by java;


--------------------------------  뷰( VIEW )  ---------------------------------
/*  뷰
     뷰(view)란 '보다'란 의미를 갖고있는 점을 감안해 보면 알수 있듯 실제 테이블에
     저장된 데이터를 뷰를 통해서 볼 수 있도록 한다.
     
     뷰를 흔히 가상 테이블이라고 부르는데 이는 테이블과 거의 동일하게 사용되기 때문이다.
     
     뷰는 물리적인 구조인 테이블과 달리 데이터 저장 공간이 없다.
     뷰는 단지 쿼리문을 저장하고 있는 객체라고 표현할 수 있다.
*/

create view view_emp10
as select empno, ename, sal,deptno from emp01 where deptno=10;

select * from tab;



