/*
무결성 제약조건
  - 데이터를 추가, 수정, 삭제하는 과정에서 무결성을 유지할 수 있도록 제약을 주는 것을 의미함
  - 무결성: 데이터베이스 내에 데이터의 확장성을 유지하는 것을 의미하고, 제약 조건이란
    제약조건: 바람직하지 않은 데이터가 저장되는 것을 방지하기 위함
    
    무결성 제약 조건
    NOT NULL    : NULL을 허용하지 않는다.
    UNIQUE      : 중복된 값을 허용하지 않는다. 항상 유일한 값을 갖도록 함
    PRIMARY KEY : NOT NULL + UNIQUE 조건을 결합한 형태를 의미함
    FOREIGN KEY : 참조되는 테이블의 컬럼값이 존재하면 허용됨
    CHECK       : 저장 가능한 데이터 값의 범위나 조건을 지정하여 설정한 값만을 허용함
*/

select * from emp01;
create table emp01(
empno number(4),
ename varchar(10),
job varchar2(9),
depno number(4));

insert into emp01 values(null,null,'salesman',30);
select * from emp01;
-- NOT NULL 제약조건은 해당 컬럼에 null값을 추가하거나 null값으로 변경하는 것을 막음
-- 제약조건은 컬럼명과 자료형을 기술한 후에 이어서 not null을 기술하면 됨

create table emp02(
empno number(4) not null,
ename varchar(10) not null,
job varchar2(9),
depno number(4));
insert into emp02 values(null,null,'salesman',30);

-- UNIQUE: 중복된 값을 허용하지 않는다. 항상 유일한 값을 갖도록 함

create table emp03(
empno number(4) UNIQUE,
ename varchar(10) not null,
job varchar2(9),
depno number(4));
insert into emp03 values(7499,'ALLEN','salesman',30);
insert into emp03 values(NULL,'HAEYOUNG','manager',20);
insert into emp03 values(null,'ALLEN','salesman',10);

/*
 unique: null값을 예외로 간주함, 만약 null값 마저도 입력되지 않게 제한 하려면
         테이블 생성시 empno number(4) unique not null처럼 두 가지 제약조건을
         기술해야함
*/
desc user_tables;

show user;

/*
제약 조건 확인 하기
  제약조건의 에러 메시지에 대한 정확한 원인을 알기 위해 오라클에서 제공해 주는 user_constraints 데이터 딕셔너리
  
    user_constraint 데이터 딕셔너리
      - 제약조건의 정보를 위해서 많은 컬럼으로 구성되어 있지만
        제약조건명, 제약 조건유형, 제약 조건이 속한 테이블만을 알아봄
*/

select constraint_name, constraint_type, table_name from user_constraints where table_name='EMP03';


/*
제약 조건 확인하기
  제약조건의 에러 메세지에 대한 정확한 원인을 알기 위해 오라클에서 제공해 주는 user_constraints
  데이터 딕셔너리
  
  user constraints 데이터 딕셔너리
    - 제약조건의 정보를 위해서 많은 컬럼으로 구성되어 있지만
      제약조건명, 제약 조건유형, 제약 조건이 속한 테이블만을 알아봄
*/
select constraint_name, constraint_type, table_name from user_constraints where table_name = 'EMP03';

/*
 constraint_type 은 p,r,u,c 4가지가 있음
 
       P : PRIMARY KEY
       R : FOREIGN KEY
       U : UNIQUE
       C : CHECK NOT NULL
*/
/*
  PRIMARY KEY 제약 조건
    - 식별 기능을 갖는 컬럼은 유일하면서도 NULL 값을 허용하지 않음
      즉, UNIQUE와 not null 제약 조건 모두를 갖는 것이 기본키(PRIMARY KEY) 제약조건임.
*/
create table emp04(
empno number(4) PRIMARY KEY,
ename varchar(10) not null,
job varchar2(9),
depno number(4));

insert into emp04 values(7499,'ALLEN','SALESMAN',30);
insert into emp04 values(7499,'JONES','MANAGER',20);


select constraint_name, constraint_type, table_name from user_constraints where table_name = 'EMP04';

select * from emp04;
insert into emp04 values(7566,'JONES','MANAGER',50);
delete from emp04 where depno=20;


create table emp05(
empno number(4) PRIMARY KEY,
ename varchar(10) not null,
job varchar2(9),
deptno number(4));

select * from dept01;

create table dept01(
deptno number(2) PRIMARY key,
dname varchar2(14),
loc VARCHAR2(13)
);

insert into dept01 values(10,'ACCOUNTING','NEW YORK');
insert into dept01 values(20,'RESEARCH','DALLAS');
insert into dept01 values(30,'SALES','CHICAGO');
insert into dept01 values(40,'OPERATIONS','BOSTON');

create table emp05(
empno number(4) PRIMARY KEY,
ename varchar(10) not null,
job varchar2(9),
deptno number(4)REFERENCES dept01(deptno)
);

select constraint_name, constraint_type, table_name from user_constraints where table_name = 'EMP05';
select * from emp05;
insert into emp05 values(7499,'ALLEN','SALESMAN',30);
insert into emp05 values(7566,'JONES','MANAGER',50);

drop table dept01; 
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'EMP05';

select * from tab;
--------------------------------------------------------------------------------

/*
   CHECK 제약조건
     - 입력되는 값을 체크하여 설정된 값 이외의 값이 들어오면 오류 메세지와 함께 명령이 수행되지 못하게 하는 것
*/
/*
   EMP06 사원테이블에 GENDER(성별) 컬럼을 추가하되 GENDER 컬럼에는 'M'or'F' 두 값만 저장할 수 있는 CHECK 제약 조건 설정
*/

create table emp06(
empno number(4) PRIMARY key,
ename VARCHAR2(10) not null,
gender VARCHAR2(1) check(gender in('M','F'))
); 
insert into emp06 values (7566,'JONES','M');
select constraint_name, constraint_type, table_name, search_condition from user_constraints where table_name = 'EMP06';

/*
제약조건명 지정하기
 - 사용자가 의미있게 제약조건명을 명시하여 제약조건명만으로 어떤 제약조건을 위배했는지 알 수 있게 하는 방법
     지정방법 : COLUMN_NAME DATA_TYPE CONTRAINT constraint_name constraint_type
     
   제약조건명 명명규칙
     테이블명_컬럼명_제약조건 유형
     
   기본키 제약 조건명을 EMP06_EMPNO_PK로 지정함
     EMP05_EMPNO_PK
*/

drop table emp05;

create table emp05(
empno number(4)CONSTRAINT EMP05_EMPNO_PK PRIMARY KEY,
ename VARCHAR2(10)CONSTRAINT EMP05_ENAME_NN Not null,
job VARCHAR2(9)CONSTRAINT EMP05_JOB_UK UNIQUE,
deptno NUMBER(4)CONSTRAINT EMP05_DEPTNO_FK REFERENCES DEPT01(DEPTNO)
);

select constraint_name, constraint_type, table_name, search_condition from user_constraints where table_name = 'EMP05';

insert into emp05 values (7499,'ALLEN','SALESMAN',30);
insert into emp05 values (7499,'NULL','SALESMAN',50);
insert into emp05 values (7499,'ALLEN','SALESMAN',50);
insert into emp05 values (7500,'ALLEN','SALESMAN',50);

/*
   테이블 레벨 방식으로 제약조건 지정하기

     복합키로 기본키를 지정할 경우
      - 복합키 형태로 제약조건을 지정할 경우에는 컬럼 레벨 형식으로는 
        불가능하고 반드시!! 테이블 레벨 방식을 사용함
      
     ALTER TABLE로 제약조건을 추가할 경우
      - 테이블의 정의가 완료되어 테이블의 구조가 결정된 후에 나중에 테이블에
        제약조건을 추가하고자 할때에는 테이블 레벨 방식으로 제약조건 지정
        
     형식
       create table 테이블명(
       컬럼명1 데이터 타입1,
       컬럼명2 데이터 타입1,
       ...
       
       CONSTRAINT constraint_name constraint_type(column_name)
       );
*/

-- 테이블 레벨로 제약조건을 지정하는 방식
select * from tab;
drop table emp04;

CREATE table emp04(
empno number(4),
ename VARCHAR2(10) not null,
job VARCHAR2(9),
deptno number(4),
PRIMARY key(empno),
unique(job),
FOREIGN key(deptno) REFERENCES dept01(deptno)
); -- 테이블 정의하고 밑에다 따로 키 지정해도 됨

drop table emp03;
--  테이블 레벨에서 컬럼의 제약조건명을 지정해줄 경우 constraint 키워드를 사용함
create table emp03(
empno number(4),
ename VARCHAR2(10) CONSTRAINT emp03_ename_nn not null,
job VARCHAR2(9),
deptno number(4),
CONSTRAINT emp03_empno_pk PRIMARY key(empno),
CONSTRAINT emp03_job_uk unique(job),
CONSTRAINT emp03_deptno_fk FOREIGN key(deptno) REFERENCES dept01(deptno)
);
select constraint_name, constraint_type, table_name, search_condition from user_constraints where table_name = 'EMP03';


--------------------------- end 제약조건 지정방식 ---------------------------------
--------------------------- 제약조건 변경 ----------------------------------------
/*
 1. 제약조건 추가하기
   - 테이블 생성이 끝난 후에 제약조건을 추가하기 위해 alter table로 추가함
   
    형식
      alter table 테이블명
      add constraint constraint_name constraint_type(column_name);
*/
drop table emp01;
create table emp01(
empno number(4),
ename VARCHAR2(10),
job VARCHAR2(9),
deptno number(4)
);
select constraint_name, constraint_type, table_name, search_condition, r_constraint_name from user_constraints where table_name = 'EMP01';

-- emp01 테이블의 empno 컬럼에 기본키 설정하고, deptno 컬럼에 외래키 설정
alter table emp01
add primary key(empno);

alter table emp01
add constraint emp01_deptno_fk FOREIGN key(deptno) REFERENCES dept01(deptno);


/* 
 2. 제약조건 제거하기
   - 제약조건을 제거하기 위해서는 drop constraint 다음에 제거하고자 하는 제약조건명을 명시
   alter table 테이블명
   drop constraint 제약조건명;
*/
select constraint_name, constraint_type, table_name, search_condition, r_constraint_name from user_constraints where table_name = 'EMP01';
insert into emp05 values (7499,'ALLEN','MASTER',50);

alter table emp05
drop constraint EMP05_EMPNO_PK;

alter table emp05
drop constraint EMP05_DEPTNO_FK;

/*
   제약조건의 비활성화 CASCADE;
     - 제약조건의 비활성화란 설정된 제약조건을 잠시 사용하지 않게 하는것
     
     disable : 제약조건의 일시 비활성화
     enable : 비활성화된 제약조건을 해제하여 다시 활성화
     
*/
select constraint_name, constraint_type, table_name, search_condition, r_constraint_name from user_constraints where table_name = 'DEPT01';
select * from dept01;
insert into dept01 values(10,'ACCOUNTING','NEW YORK');
delete from dept01 where deptno=30;



drop table emp01;
create table emp01(
empno number(4) constraint emp01_empno_pk PRIMARY key,
ename VARCHAR2(10) constraint emp01_ename_nn not null,
job VARCHAR2(9),
deptno number(4) constraint emp01_deptno_fk REFERENCES dept01(deptno)
);

insert into emp01 values(7499,'ALLEN','SALESMAN',10);
insert into emp01 values(7369,'SMITH','CLERK',20);

delete from dept01 where deptno=10;

/*
   제약조건 활성화와 비활성화
    
    - 제약조건이 설정되면 항상 그 규칙에 따라 데이터 무결성이 보장됨
      오라클에서는 제약조건을 비활성화시킴으로써 제약조건을 삭제하지 않고도 사용을 잠시
      보류할 수 있으며 비활성화된 제약조건은 원하는 작업을 한 후 다시 활성화 상태로
      만들어 주어야함.
  
   활성화 방법
     alter table 테이블명
     enable constraint 제약조건명;
  
   비활성화 방법
     alter table 테이블명
     disable constraint 제약조건명;
*/
alter table emp01
     disable constraint EMP01_DEPTNO_FK;

select constraint_name, constraint_type, table_name, search_condition, r_constraint_name,status from user_constraints where table_name = 'EMP01';

delete from dept01 where deptno=10;
rollback;

-- 활성화
alter table emp01
enable constraint emp01_deptno_fk;

/*
  CASCADE
    - cascade 옵션은 부모테이블(dept01)과 자식테이블(emp01)간의 참조 설정이 되어 있을때
      부모 테이블의 제약 조건을 비활성화하면 이를 참조하는 자식테이블의 제약조건까지
      같이 비활성화 시켜주는 옵션이다
*/
alter table dept01
disable primary key cascade;

select constraint_name, constraint_type, table_name, search_condition, r_constraint_name,status
from user_constraints where table_name in('DEPT01','EMP01');

/*
  CASCADE 옵션을 지정하여 기본키 제약조건을 삭제하면 이를 참조하는 외래키 제약조건도 연속적으로 삭제
*/
alter table dept01
drop primary key cascade;

select * from dept;
select * from emp;

select * from emp , dept where emp.deptno = dept.deptno;
select * from emp e, dept d where e.deptno = d.deptno; --이것도 가능


--------------------------------  조인 (Join)  ----------------------------------
/*
  조인 : 한개 이상의 테이블에서 데이터를 조회하기 위해 사용되는것
  
  종류
    Equi join : 동일한 컬럼을 기준으로 조인
    Nonqui join : 동일한 컬럼이 없이 다른 조건을 사용하여 조인
    Outer join : 조인 조건에 만족하지 않는 행도 나타냄
    Self join : 한 테이블 내에서 조인
*/

